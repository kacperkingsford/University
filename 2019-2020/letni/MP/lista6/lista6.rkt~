#lang racket

;Ćwiczenie 1


;a)
`(+ (/ 8 (+ 2 3)) (+ 10 1))

(binop '+ (binop '/ (const 8) 
                    (binop '+ (const 2) 
                              (const 3))) 
            (binop '+ (const 10) 
                      (const 1)))

;b)
b = 1+2+3*4+5

(+ 1 (+ 2 (+ (* 3 4) 5))

(define a (binop '+ (const 1)
        (binop '+ (const 2) 
                  (binop '+ (binop '* (const 3)
                                      (const 4)) 
                            (const 5)))))
                            


(eq? (integer->char 955) (integer->char 955))
#f
(equal? (integer->char 955) (integer->char 955))
#t

(eq? (make-string 3 #\z) (make-string 3 #\z))
#f
(equal? (make-string 3 #\z) (make-string 3 #\z))
#t


;Ćwiczenie 2


(define (square x) (* x x))
(define (cont-frac-expr num den i k)
    (if (= k i)
        (const 0)
        (binop '/ 
            (const (num i)) 
            (binop '+ (const (den i)) (cont-frac-expr num den (+ i 1) k)))))

(define (pi-expr n)
    (binop '+ 
        (const 3) 
        (cont-frac-expr (lambda (i) (square (- (* 2 i) 1.0))) (lambda (i) 6.0) 1.0 n)))

;Ćwiczenie 3



(struct unop (op e))

(define (expr? e)
  (match e
    [(const n) (number? n)]
    [(binop op l r) (and (symbol? op) (expr? l) (expr? r))]
    [(unop op e) (and (symbol? op) (expr? e) )]
    [_ false]))

(define (binop->proc op)
  (match op ['+ +] ['- -] ['* *] ['/ /] ['** **]))
(define (unop->proc op)
  (match op ['abs abs]))

(define (eval e)
  (match e
    [(const n) n]
    [(unop op e) ((unop->proc op) (eval e))]
    [(binop op l r) ((binop->proc op) (eval l) (eval r))]))
    

(define (parse q)
  (cond [(number? q) (const q)]
        [(and (list? q) (eq? (length q) 2) (symbol? (first q)))
         (unop (first q) (parse (second q)))]
        [(and (list? q) (eq? (length q) 3) (symbol? (first q)))
         (binop (first q) (parse (second q)) (parse (third q)))]))
    
    
    
(define ** expt)


(eval (parse '(abs (** -2 3))))
8

;Ćwiczenie 4


  